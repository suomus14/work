
suomus14: 修正提案は不要。
> さらに logger が毎回 root ロガーにハンドラを追加する形なので、ハンドラの重複や想定外のログ動作を招く可能性もあります。
ここについて詳しく分かりやすく教えて。

GitHub Copilot: これから、なぜ「logger を毎回 root ロガーに追加するとハンドラの重複や想定外のログ動作を招く」のかを、コードの振る舞いに沿って具体的にわかりやすく説明します。実例と検出方法も示します（修正提案は含めません）。

## 概要（結論）
- Python の logging では「ロガー（logger）」と「ハンドラ（handler）」が分離されています。ロガーにハンドラを追加すると、そのハンドラは以降そのロガー（およびプロパゲーションが有効な場合は親ロガー）に届く全てのログ記録を受け取ります。
- loggerForEsprit の実装は、インスタンス生成のたびに新しいファイルハンドラを作り、`logging.getLogger()`（引数なし → ルートロガー）に対して `addHandler()` しています。ループ等で何度もインスタンス化すると、root ロガーにハンドラがどんどん追加されます。
- その結果、同一プロセス内であっても「複数のファイルハンドラが並列に並び、各ハンドラが各ファイルへ同じログを吐く」ため、MAStopSeq_<日時>_<PID>.log のようなログファイルが複数出力される（意図せず同じログが複数のファイルに複製される）。

以下で詳しく分解します。

## 動作の詳細（loggerForEsprit の動きに沿って）
loggerForEsprit.py の重要箇所（要点のみ）
- 初期化（__init__）で：
  - self.FILE ハンドラ（RotatingFileHandler や FileHandler）を作る
  - logging.basicConfig(...) を呼ぶ（最初の一回しか効果がないが呼ばれている）
  - logger = logging.getLogger()  <-- 引数なしなので「root ロガー」を取得
  - logger.addHandler(self.file_handler)  <-- root にハンドラを追加
- getLogger() 関数はモジュールレベルの global logger を返すが、__init__ で global logger に root ロガーオブジェクトが格納されるため、その後は root ロガーが返される形になっています。

重要な点：
- logging.getLogger()（引数なし）は root logger を返す
- root ロガーにハンドラを追加すると、以後 root を経由するログがそのハンドラにも届く
- addHandler() は同じハンドラを二重追加するチェックを自動でしない → 同じ処理を何度でも追加できる（別ハンドラなら別々に動作する）

## なぜ「複数ログファイルが出る」のか（因果）
1. MAStopSeq リカバリ処理では、TSV ファイルごとに `MAStopSeqExecutor` を新しく作っていた（ループ内で new）。
2. `MAStopSeqExecutor` の初期化（BaseExecutor.__init__）は loggerForEsprit.loggerForEsprit(...) を呼び、loggerForEsprit.__init__ はそのたびに新しい file handler（出力先に appendUniqueSuffix を付けたファイル名）を作って root に add する。
3. したがって 1 回のプロセス実行で複数回 Executor を作ると、root に複数の file handler が積み上がる。各 handler はそれぞれ別ファイル（ファイル名に時間や PID が付くため微妙に異なる）に同じログを出力する。
4. 結果：同一のログメッセージ群が複数の log ファイルに複製される。加えて、handler が増えるほどログ出力処理のオーバーヘッドが増え、メモリや I/O 負荷が上がる。

## 具体的に起きる現象（観察される問題点）
- 同一プロセス（同一 PID）なのに、MAStopSeq_<YYYYMMDDHHMM>_<PID>.log が複数生成される。
- それぞれのファイルに同じログ行が複製される（ファイルごとに同一内容）。
- ログハンドラが増えるたびにログ出力にかかる時間が増す → 大量ファイル処理時に遅延や I/O ボトルネックが発生しやすい。
- ハンドラが適切に削除されないと（removeHandler が呼ばれない等）プロセス終了までハンドラが残り続け、メモリやファイルディスクリプタを圧迫する可能性がある。
- root ロガーにハンドラを追加しているため、ライブラリや他モジュールが出すログまで意図せず各ファイルに出力されることがある（ログの分離性が壊れる）。

## なぜ「重複ログ」が起きる仕組み（より技術的に）
- logging の流れ：ロガー（例: logging.getLogger('foo')）がログを生成 → ロガー自身の handlers を呼ぶ → propagate が True（デフォルト）なら親ロガーへ伝播し、最終的に root がもつ handlers でも出力される。
- 今回は root に複数のハンドラ（file handlers）が追加されているため、root がログを受け取るたびに登録済みすべてのハンドラが走る。結果、複数ファイルに同じレコードが書かれる。
- また addHandler は同一のハンドラオブジェクトを何度も add すると同じハンドラ参照が複数回登録される（ログが複数回書かれる）が、今回のケースは毎回別ハンドラ（別ファイル名）を追加しているため「別ファイル × 同じレコード」となる。

## 実際に状態を確認する方法（簡単な手順）
Python REPL かスクリプトで root ロガーのハンドラ数や各ハンドラのファイル名を確認できます。簡易検査例（説明用）：

- ハンドラ数を見る（対話的に）
```python
import logging
root = logging.getLogger()
print(len(root.handlers))
for h in root.handlers:
    print(type(h), getattr(h, 'baseFilename', None))
```
- 上の出力で file handler が複数列挙され、baseFilename がそれぞれ別の MAStopSeq_*.log を指していれば「複数ハンドラ追加」が起きています。

## どのログがどこから追加されたかの追跡
- 各ハンドラがどのタイミングで追加されたかは、ハンドラ生成時にスタックトレースをログするか、その場でログに記録する実装がなければ直接は分かりにくいです。簡易的には、Executor を生成する箇所の前後で上の `len(root.handlers)` を出力して増分を追えばどの箇所で追加されたかが分かります。

## まとめ（ポイントだけ）
- root ロガーへハンドラを何度も追加すると、追加した分だけログ出力が複数先へ行く（複製される）。
- loggerForEsprit の現在の実装は「インスタンスごとに file handler を生成して root に追加する」ため、Executor をループ内で毎回作るような使い方をすると、意図せず複数のログファイルが生成され、同じログが複数のファイルへ書き込まれる。
- ハンドラ増加はログの重複以外に性能（I/O）・リソース（ファイルディスクリプタ、メモリ）の問題も引き起こす。

もし要望があれば、（1）現在の実行環境で増えているハンドラを確認するテスト用スクリプト、または（2）ハンドラの重複を検出する診断手順（実行ログを取る方法）を提示できます（修正提案ではなく、現状把握のための追加情報です）。どちらにしますか？
